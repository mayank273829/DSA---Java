//question 1 write the code for Binary serach ?

public class Bs{
public static void main(String[] args){
int [] arr = {1,2,3,4,5};
int target  = 4;
int result = Search(arr, target);
System.out.println(result);
}

public static int Search(int [] arr, int target){
int start = 0;
int end = arr.lngth-1;

while(start <= end){
int mid = start + (end-start)/2;

if(arr[mid] == target){
return mid;
}
else if(arr[mid] < target){
start = mid + 1;
}
else {
end = mid -1;
}
}
return -1;
}
}


// question 2 Find minimum in rotated sorted array

Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array



solution - >

class Solution {
    public int findMin(int[] nums) {
        int start = 0;
        int end = nums.length-1;
        while(start < end){
            int mid = start + (end-start)/2;
            
            if(nums[mid] > nums[end]){
                 start = mid + 1;
            }else{
                 end = mid;
            }
        }
        return nums[start];
    }
}


// question 3 Search in rotated sorted array

solution -> 
class Solution {
    public int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        int peak = pivot(nums);
        int ans = binarySearch(nums, target, start, peak);
        if(ans != -1){
            return ans;
        }else{
           return binarySearch(nums, target, peak + 1, end);

        }
    }
    public int pivot(int[] nums){
        int start = 0;
        int end = nums.length - 1;
        while(start < end){
            int mid = start + (end - start)/2;
            if(mid < end && nums[mid] > nums[mid + 1]){
                return mid;
            }if(mid > start && nums[mid] < nums[mid - 1]){
                return mid - 1;
            }if(nums[mid] <= nums[start]){
                end = mid - 1;
            }else{
                start = mid + 1;
            }
        }
        return nums.length -1;
    }
    public int binarySearch(int[] nums, int target, int start, int end){
        while(start <= end){
            int mid = start + (end - start)/2;
            if(target == nums[mid]){
                return mid;
            }else if(target < nums[mid]){
                end = mid - 1;
            }else{
                start = mid + 1;
            }
        }
        return -1;
    }
}


//question 4 Single Element in a Sorted Array

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return the single element that appears only once.

Your solution must run in O(log n) time and O(1) space.

solution ->  

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int start = 0;
        int end = nums.length -1;

        while(start < end){
            int mid = start + (end-start)/2;
            if(mid % 2 == 1){
                mid--;
            }
           if(nums[mid] == nums[mid +1]){
                start = mid + 2;
            }else{
            end = mid;
            }
        }
        return nums[start];
    }
}

//question 5 
Find Peak ElementGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks,
return the index to any of the peaks.You may imagine that nums[-1] = nums[n] = -âˆž. In other words, an element is always considered to be
strictly greater than a neighbor that is outside the array.You must write an algorithm that runs in O(log n) time.



class Solution {
    public int findPeakElement(int[] nums) {
        int start = 0;
        int end = nums.length -1;

        while(start < end){
            int mid = start + (end - start)/2;

            if(nums[mid] > nums[mid + 1]){
                end = mid;
            }else{
                start = mid + 1;
            }
        }
        return start;
    }
}


// question 6 Peak Index in a Mountain Array

You are given an integer mountain array arr of length n where the values increase to a peak element and then decrease.

Return the index of the peak element.

Your task is to solve it in O(log(n)) time complexity.


solution -> 

class Solution {
    public int peakIndexInMountainArray(int[] arr) {
       int start = 0;
       int end = arr.length -1;

       while(start < end){
        int mid  = start + (end - start)/2;

        if(arr[mid] < arr[mid +1]){
           start = mid + 1;
        }else{
            end = mid;
        }
       }
       return start;
}
}


//question 6 
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product
fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. 
You should minimize the number of calls to the API.


solution ->
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int start = 1;
        int end = n;

        while(start < end){
            int mid = start + (end - start)/2;

            if(isBadVersion(mid)){
                end = mid;
            }else{
                start = mid + 1;
            }
        }
        return start;
    }
}


question 7  (leetcode 74.) Search a 2D Matrix

You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity.


solution ->

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int r = 0; r < matrix.length; r++){
            for(int c = 0; c < matrix[r].length; c++){
                if(matrix[r][c] == target){
                    return true;
                }
            }
        }
        return false;
    }
}


question 8 (LeetCode 240 medium level) Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. 
This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {

        for(int row = 0; row < matrix.length; row++){
        int start = 0;
        int end = matrix[row].length -1;

        while(start <= end){
            int mid = start + (end - start)/2;

            if(matrix[row][mid] == target){
                return true;
            }else if(matrix[row][mid] < target){
                start = mid +1;
            }else{
                end = mid -1;
            }

        }
    }
    return false;
    }
}

// question 9 
81. Search in Rotated Sorted Array II (Medium)

There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).

Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is 
[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated 
at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].

Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.

You must decrease the overall operation steps as much as possible.



solution ->

class Solution {
    public boolean search(int[] nums, int target) {
       int start = 0;
       int end = nums.length -1;

       while(start <= end){
        int mid = start + (end-start)/2;

        if(nums[mid] == target){
            return true;
        }

        if(nums[mid] == nums[start] && nums[mid] == nums[end]){
            start++;
            end--;
            continue;
        }

         // if left half is sorted.

         if(nums[start] <= nums[mid]){
            if(nums[start] <= target && target < nums[mid]){
               end = mid -1;
            }else{
                start = mid +1;
          }
            

         // if right half is sorted.

         }else{
            if(nums[mid] < target && target <= nums[end]){
                start = mid +1;
            }else{
                end = mid -1;
            }
         }
       } 
       return false;
    }
}


//question 10 

74. Search a 2D Matrix (Medium)
You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

You must write a solution in O(log(m * n)) time complexity



solution ->

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int row = matrix.length; // calculates how many rows are present.
        int cols = matrix[0].length; // claculate how many columns are present.

        int start = 0;
        int end = row * cols - 1;

        while(start <= end){
            int mid = start + (end - start)/2;
            int r = mid / cols; // row number
            int c = mid % cols; // column number

            if(matrix[r][c] == target){
                return true;
            }else if(matrix[r][c] < target){
                start = mid + 1;
            }else{
                end = mid - 1;
            }
        }
        return false;
    }
}
 

